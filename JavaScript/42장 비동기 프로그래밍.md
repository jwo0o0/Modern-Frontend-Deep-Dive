# 42. 비동기 프로그래밍

## 42.1 동기 처리와 비동기 처리

---

```jsx
const foo = () => {};
const bar = () => {};

foo();
bar();
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7fcc553f-a6b8-4870-a93c-292d8556f276/4a84565e-ecbc-4430-9422-5d9de5ada2f9/Untitled.png)

함수를 호출하면 → 함수 코드가 평가되어 함수 실행 컨텍스트가 생성됨

→ **콜 스택(실행 컨텍스트 스택에)** 함수 실행 컨텍스트가 **푸시**됨

→ 함수 코드 실행이 종료하면 콜 스택에서 팝되어 제거됨

> 📌 **자바스크립트 엔진**: **단 하나의 실행 컨텍스트 스택**을 가짐

- 한 번에 하나의 태스크만 실행할 수 있는 **싱글 스레드 방식으로 동작**
  >
- 처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹(작업 중단)이 발생

```jsx
function sleep(func, delay) {
  const delayUntil = Date.now() + delay;
  while (Date.now() < delayUntil);
  func();
}

function foo() {
  console.log("foo");
}
function bar() {
  console.log("bar");
}

sleep(foo, 3 * 1000);
```

![동기 처리](https://prod-files-secure.s3.us-west-2.amazonaws.com/7fcc553f-a6b8-4870-a93c-292d8556f276/2b25d9c8-416c-400c-982e-2d04315d9ef6/Untitled.png)

동기 처리

- 이처럼 **현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식**을 **동기 처리**(synchronous)라고 함

```jsx
function foo() {
  console.log("foo");
}
function bar() {
  console.log("bar");
}

setTimeout(foo, 3 * 1000);
bar();
// bar 호출 -> 3초 경과 후 foo 호출
```

![비동기 처리](https://prod-files-secure.s3.us-west-2.amazonaws.com/7fcc553f-a6b8-4870-a93c-292d8556f276/58567316-5558-48a5-aeb6-a3470614d586/Untitled.png)

비동기 처리

- `setTimeout` 함수는 이후의 태스크를 블로킹하지 않고 곧바로 실행
- 이처럼 **현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식**을 **비동기**(asynchronous)처리 라고함
- 비동기 처리는 블로킹이 발생하지 않지만, **태스크의 실행 순서가 보장되지 않음**

## 42.2 이벤트 루프와 태스크 큐

---

<aside>
💡 자바스크립트의 특징 중 하나 - **싱글 스레드로 동작**
하지만 브라우저가 동작하는 것을 보면 많은 태스크가 동시에 처리되는 것처럼 느껴짐
→ **이벤트 루프**가 **자바스크립트의 동시성(concurrency)을 지원**하기 때문

</aside>

![이벤트 루프와 브라우저 환경](https://prod-files-secure.s3.us-west-2.amazonaws.com/7fcc553f-a6b8-4870-a93c-292d8556f276/8fadeb38-afda-46c7-9b85-7166d878c45b/Untitled.png)

이벤트 루프와 브라우저 환경

### 자바스크립트 엔진의 영역

1. **콜 스택**

   소스코드 평가 과정에서 생성된 **실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택**

   자바스크립트 엔진은 단 하나의 콜 스택을 사용하기 때문에 최상위 실행 컨텍스트(실행 중인 컨텍스트)가 종료되기 전까지는 다른 어떤 태스크도 실행되지 않음

2. **힙**

   **객체가 저장되는 메모리 공간**, 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조

   할당해야 할 **메모리 공간의 크기를 런타임에 결정(동적 할당)** → 힙은 구조화 되어있지 않음

⇒ 비동기 처리에서 **소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당**

e.g. 비동기 방식으로 동작하는 `setTimeout`의 **콜백 함수의 평가와 실행은 JS엔진**이 담당하지만, 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 Node.js가 담당

→ **브라우저 환경**: 태스크 큐와 이벤트 루프를 제공

- **태스크 큐(task queue / event queue / callback queue)**
  비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역
- **이벤트 루프(event loop)**
  **콜 스택**에 **현재 실행 중인 실행 컨텍스트가 있는지**, **태스크 큐**에 **대기 중인 함수가 있는지 반복해서 확인**
  → 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 FIFO로 태스크 큐에서 대기 중인 함수를 콜 스택으로 이동

```jsx
function foo() {
  console.log("foo");
}
function bar() {
  console.log("bar");
}

setTimeout(foo, 0); // 0초(실제는 4ms) 후에 foo 함수가 호출
bar();
```

1. 전역 코드가 평가: 전역 실행 컨텍스트가 생성되고 콜 스택에 푸시
2. 전역 코드 실행: `setTimeout` 함수 호출 → `setTimeout` 함수 실행 컨텍스트 생성, 콜 스택에 푸시, 현재 실행 중인 실행 컨텍스트가 됨 (브라우저의 Web API인 타이머 함수도 실행 컨텍스트를 생성)
3. `setTimeout` 함수가 실행: 콜백 함수를 호출 스케줄링하고 종료되어 콜 스택에서 pop

   이때 **브라우저**가 타이머를 설정하고 타이머 만료시 콜백 함수를 태스크 큐에 푸시함

4. **브라우저가 수행하는 4-1**과 **자바스크립트 엔진이 수행하는 4-2**는 **병행 처리**

   4-1. 브라우저는 타이머를 설정하고 만료를 기다림 → 만료시 콜백 함수 foo가 태스크 큐에 푸시(최소 지연 시간 4ms)

   이 때 콜백 함수가 태스크 큐에 푸시되어 대기하지만 콜 스택이 비어야 호출되므로 정확히 지연 시간 후에 호출된다는 보장은 없음

   4-2. bar 함수가 호출되어 bar 함수의 실행 컨텍스트가 호출되고 콜 스택에 푸시되어 현재 실행 중인 컨텍스트가 됨 → 이후 bar 함수가 종료되고 콜 스택에서 pop

   이 때 브라우저가 타이머를 설정한 후 4ms가 경과했다면 **foo 함수는 아직 태스크 큐에서 대기 중**

5. 전역 코드 실행이 종료되고 전역 실행 컨텍스트가 콜 스택에서 pop
6. **이벤트 루프**에 의해 콜 스택이 비어 있음이 감지되고 태스크 큐에서 대기 중인 콜백 함수 foo가 콜 스택에 푸시 → 이후 foo 함수가 종료되어 콜 스택에서 pop

> 비동기 함수인 `setTimeout`의 콜백 함수는 태스크 큐에 푸시되어 대기하다 **콜 스택이 비게 되면 비로소 콜 스택에 푸시되어 실행**

<aside>
💡 **자바스크립트**: **싱글 스레드 방식**으로 동작
→ 이 때 싱글 스레드 방식으로 동작하는 것은 브라우저가 아니라 **브라우저에 내장된 자바스크립트 엔진
🚨 즉, 자바스크립트 엔진은 싱글 스레드로 동작하지만, 브라우저는 멀티 스레드로 동작**

</aside>
