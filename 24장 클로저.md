# 24. 클로저

> MDN: 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

```jsx
const x = 1;

function outerFunc() {
  const x = 10;
  innerFunc();
}

function innerFunc() {
  console.log(x); // 1
}

outerFunc();
```

- 중첩 함수 `innerFunc`의 상위 스코프 = 외부 함수 `outerFunc`의 스코프
  → `innerFunc` 함수에서 outer `Func` 함수의 변수에 접근할 수 없음
  - **자바스크립트가 렉시컬 스코프를 따르는 프로그래밍 언어이기 때문!**

## 24.1 렉시컬 스코프

💡 자바스크립트 엔진: 
함수를 어디서 호출했는지가 아니라 **함수를 어디서 정의했는지에 따라 상위 스코프를 결정** - **렉시컬 스코프(정적 스코프)**


```jsx
const x = 1;
function foo() {
  const x = 10;
  bar();
}
function bar() {
  console.log(x);
}
foo(); // 1
bar(); // 1
```

- `foo` 함수, `bar` 함수의 상위 스코프 = 전역 스코프

> 📌 **스코프**의 실체: **실행 컨텍스트의 렉시컬 환경**

- 렉시컬 환경은 “외부 렉시컬 환경에 대한 참조”를 통해 상위 렉시컬 환경과 연결 (스코프 체인)

## 24.2 함수 객체의 내부 슬롯 [[Environment]]

- **함수**: 자신의 내부 슬롯 `[[Environment]]`에 자신이 정의된 환경, 즉 **상위 스코프의 참조를 저장**
  - 함수 정의가 평가되어 함수 객체를 생성할 때
    → **현재 실행 중인 실행 컨텍스트의 렉시컬 환경이 함수의 `[[Environment]]`에 저장됨**

![image](https://github.com/jwo0o0/Modern-Javascript-Deep-Dive/assets/70098708/82bb5d0c-0746-4a6a-921f-12de4703421b)


## 24.3 클로저와 렉시컬 환경

```jsx
const x = 1;

function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}

const innerFunc = outer();
innerFunc(); // 10
```

1. `outer` 함수 평가 후 함수 객체 생성
2. 중첩 함수 `inner`가 평가됨
3. `outer` 함수 호출

   → `inner` 함수를 반환하고 생명 주기 마감, `outer` 함수의 실행 컨텍스트가 실행 컨텍스트 스택에서 pop

4. 그러나 outer 함수의 지역 변수 x 값인 10이 출력됨

💡 **외부 함수보다 중첩 함수가 더 오래 유지**되는 경우 
→ 중첩 함수는 **이미 생명 주기가 종료한 외부 함수의 변수를 참조**할 수 있음
이러한 중첩 함수 = **클로저(closure)**


- 함수: 언제나 자신이 기억하는 상위 스코프의 식별자를 참조 가능
- `outer` 함수의 렉시컬 환경이 `inner` 함수의 `[[Environment]]` 내부 슬롯에 의해 참조되고 있고, `inner` 함수는 `innerFunc`에 의해 참조되고 있음 ⇒ **가비지 컬렉션의 대상이 아님!**
- 외부 함수보다 더 오래 생존한 중첩 함수: 외부 함수의 생존여부와 상관없이 식별자를 참조하거나 값 변경 가능

### 클로저의 조건

1. **중첩 함수가 상위 스코프의 식별자를 참조하고,**
2. **중첩 함수가 외부 함수보다 더 오래 유지되는 경우**

- 자유 변수(free valuable): 클로저에 의해 참조되는 상위 스코프의 변수
- **모던 자바스크립트 엔진**: 최적화가 잘 되어 있어 클로저가 참조하고 있지 않은 식별자는 기억하지 않음(메모리 낭비 없음)
