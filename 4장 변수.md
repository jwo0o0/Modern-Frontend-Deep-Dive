# 4장 변수

## 4.1

- **자바스크립트**는 <span style='background-color: #fff5b1'>개발자가 컴퓨터의 메모리를 직접적으로 제어하는 것을 허용하지 않음 </span>
    
    → 허용한다면: 값이 저장될 때 메모리의 주소는 임의로 결정됨, 동일한 컴퓨터에서 동일한 코드를 실행시켜도 달라짐
    
    → 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 재사용하기 위해 변수(variable)를 사용
    

## 4.2

- 변수 이름 = 식별자(identifier) = 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름
- 식별자는 값이 아니라 **메모리 주소를 기억**하고 있음!

## 4.3

- 변수 선언(variable declaration)
    
    : 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름 - 메모리 공간의 주소를 연결(**binding**)
    

### 변수 선언 키워드

1. var: 블록 레벨 스코프 지원 x, 함수 레벨 스코프 지원
2. let
3. const

```jsx
var score;
```

→ 자바스크립트: 변수 이름을 등록하고 메모리 공간 확보, 메모리 공간에는 **자바스크립트 엔진에 의해 undefined 값 할당(assign)으로 초기화(initialization)**

+) 변수 이름: **execution context**에 등록

= 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역

*var 키워드로 선언한 변수: 암묵적으로 undefined로 초기화가 자동으로 수행

## 4.4

```jsx
console.log(score); // undefined 

var score;
```

- 변수 선언: **런타임 이전 단계에서 먼저 실행**
    
    *자바스크립트 엔진: 런타임 전에 소스코드의 평가 과정을 거침, **이 때 모든 선언문을 찾아내 먼저 실행**
    

### 변수 호이스팅(variable hoisting)

- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 js 고유의 특징

## 4.5

### 변수 할당

- 변수 선언과 다르게 할당은 **런타임에 실행!**

```jsx
console.log(score); // undefined
var score = 80;
console.log(score); // 80
```

## 4.6

### 값의 재할당

- 변수가 재할당 될 때, 새로운 메모리 공간이 확보됨 (기존 메모리 공간의 값이 바뀌는 것이 아님!)
    
    → **필요 없는 메모리 공간은 가비지 콜렉터가 해제** → memory leak 방지
    

### unmanaged language vs. managed language

- **unmangaed**: C, C++, Assembly → 개발자가 명시적으로 메모리를 할당하고 해제 가능 저수준 메모리 제어 가능
- **managed**: java, javascript, python, C# → 개발자의 메모리 제어 허용 x, 가비지 콜렉터가 메모리 제어

## 4.7

### 네이밍

- 변수, 함수 이름: 카멜 케이스
- 생성자 함수, 클래스 이름: 파스칼 케이스
