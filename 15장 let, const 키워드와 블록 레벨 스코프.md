# 15. let, const 키워드와 블록 레벨 스코프

## 15.1

## var 키워드

### **1. 중복 선언이 가능**

```jsx
var x = 1;
var y = 1;

var x = 100; // 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작
var y; //초기화문이 없으므로 무시
```

- 재선언시:  var 키워드가 없는 것처럼 동작

### 2. **함수 코드 블록만 지역 스코프로 인정**

```jsx
var x = 1;
if (true) {
	var x = 10; // x는 의도치 않게 전역변수가 됨
}
console.log(x); // 10
```

→ 의도치 않게 전역 변수가 중복 선언되는 경우가 발생할 수 있음

### 변수 호이스팅

var 키워드로 변수 선언 ⇒ 변수 호이스팅 발생

```jsx
console.log(foo); // undefined

foo = 123;

console.log(foo); // 123

var foo;
```

- 자바스크립트 엔진: 해당 스코프의 선두에 변수가 선언되고 undefined로 초기화된 것처럼 동작
    
    → 가독성을 떨어뜨리고 오류를 발생시킬 위험이 있음
    

## 15. 2

## let 키워드

### 1. 변수 중복 선언 금지

```jsx
let bar = 123;
let bar = 456; // syntax error
```

### 2. 블록 레벨 스코프

- **모든 코드 블록을 지역 스코프로 인정**하는 블록 레벨 스코프를 따름

### 변수 호이스팅
![호이스팅](https://user-images.githubusercontent.com/70098708/180654995-ccd65a5b-10f3-4190-bce2-2a4f3a61e025.png)


### var 키워드

- 선언 단계와 초기화 단계가 한번에 진행
- 선언 단계에서 스코프에 변수 식별자를 등록

### let 키워드

- 선언 단계와 초기화 단계가 분리
- 변수 호이스팅이 발생하지 않는 것처럼 동작 → 하지만 그렇지 않음!
    
    ```jsx
    let foo = 1;
    
    {
    	console.log(foo); // reference error
    	let foo = 2; // 지역 변수
    }
    ```
    
    *변수 호이스팅이 발생하지 않는다면 - 전역 변수 foo의 값을 출력해야 함
    

### javascript의 호이스팅

- 모든 선언은 호이스팅 됨
- let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작

### 전역 객체와 let

```jsx
var x = 1;
console.log(Window.x); // 1

let y = 2;
console.log(Window.y); // undefined
```

**var** 키워드로 선언된 전역 변수, 전역 함수 ⇒ **전역 객체 Window의 프로퍼티**가 됨

**let** 키워드로 선언된 전역 변수, 전역 함수 ⇒ 전역 객체의 프로퍼티 X, **실행 컨텍스트에 존재**하게 됨

## 15.3

## const 키워드

### 선언과 초기화

- const 키워드로 선언한 변수: 반드시 선언과 동시에 초기화해야 함

### 재할당 금지

```jsx
const foo = 1;
foo = 2; // typeError
```

### 상수

📌  상수 : 재할당이 금지된 변수

- const 키워드로 선언된 변수에 할당된 객체: 변경 가능!
    
    → 객체는 변경 가능한 값, 재할당 없이 직접 변경이 가능함
    
    → const 변수에 할당된 참조 값은 변하지 않음
