# 23. 실행 컨텍스트

## 23.1 소스코드의 타입

![image](https://github.com/jwo0o0/Modern-Javascript-Deep-Dive/assets/70098708/fc01dd47-f189-419c-b41c-ed61e1a8e61a)


1. **전역 코드(global code)**

   > 전역에 존재하는 소스코드. 전역에 정의된 함수, 클래스 등 내부 코드는 포함 X

   - 최상위 스코프인 전역 스코프 생성
   - var 키워드로 선언된 전역 변수, 전역 함수 → 전역 객체의 프로퍼티와 메서드로 바인딩

2. **함수 코드(function code)**

   > 함수 내부에 존재하는 소스코드. 함수 내부에 중첩된 함수, 클래스 등 내부 코드는 포함 X

   - 지역 스코프 생성
   - 지역 변수, 매개변수, arguments 객체 관리
   - 지역 스코프를 스코프 체인의 일원으로 연결

3. **eval 코드**

   > 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드

   - strict mode에서 자신만의 독자적인 스코프 생성

4. **모듈 코드(module code)**

   > 모듈 내부에 존재하는 소스코드. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함 X

   - 모듈별로 독립적인 모듈 스코프 생성

## 23.2 소스코드의 평가와 실행

![image](https://github.com/jwo0o0/Modern-Javascript-Deep-Dive/assets/70098708/de0163e3-ed71-41da-b850-1691a9408468)

### 자바스크립트 엔진

1. **소스코드의 평가(선언문)**

   실행 컨텍스트를 생성하고 **변수, 함수 등의 선언문만 먼저 실행**

   → 실행 컨텍스트가 관리하는 스코프에 등록

2. **소스코드의 실행**

   런타임이 시작 → 소스코드 실행에 필요한 정보를 스코프에서 검색해서 취득

   소스코드의 실행 결과는 다시 스코프에 등록

```jsx
var x;
x = 1;
```

1. **소스코드 평가**
   - `var x;` 먼저 실행
   - 변수 식별자 x가 스코프에 등록되고 `undefined`로 초기화
2. **소스코드 실행**
   - 먼저 x 변수가 선언된 변수인지 확인 ⇒ 스코프에 x변수가 등록되어 있는지 확인
   - x 변수가 선언된 변수라면 값 할당하고 할당 결과를 실행 컨텍스트에 등록

## 23.2 실행 컨텍스트의 역할

```jsx
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

//메서드 호출
console.log(x + y); // 3
```

### 1. 전역 코드 평가

전역 코드의 변수 선언문과 함수 선언문 먼저 실행

→ **전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록**됨

- var 전역 변수, 함수 선언문으로 정의된 전역 함수 ⇒ 전역 객체의 프로퍼티와 메서드가 됨

### 2. 전역 코드 실행

런타임 실행 → 전역 코드가 순차적으로 실행됨

- 함수 호출시 → 전역 코드의 실행을 일시 중단, 함수 내부로 진입

### 3. 함수 코드 평가

함수 코드 평가: 매개변수와 지역 변수 선언문 먼저 실행

→ **실행 컨텍스트가 관리하는 지역 스코프에 등록**

- `arguments` 객체가 생성되어 지역 스코프에 등록
- `this` 바인딩 결정

### 4. 함수 코드 실행

함수 코드 순차적으로 실행

- `console` 식별자를 스코프 체인을 통해 검색: 상위 스코프인 전역 스코프와 연결
- `log` 프로퍼티를 `console` 객체의 프로토타입 체인을 통해 검색
- `a, x, y` 식별자: 스코프 체인을 통해 검색

<aside>
💡 **코드가 실행되려면…**

1. 모든 식별자(변수, 함수, 클래스 등)를 **스코프를 통해 등록하고 상태변화를 지속적으로 관리**할 수 있어야 함
2. 스코프는 **중첩 관계에 의해 스코프 체인** 형성: 상위 스코프로 이동하며 식별자 검색
3. 현재 **실행 중인 코드의 실행 순서를 변경**하고 다시 되돌아갈 수 있어야 함

</aside>

### 실행 컨텍스트

> 소스코드를 실행하는데 필요한 환경을 제공하고, 코드의 실행 결과를 실제로 관리하는 영역

- 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘
- 모든 코드는 실행 컨텍스트를 통해 실행되고 관리됨

1. **식별자, 스코프** **⇒ 렉시컬 환경**으로 관리
2. **코드 실행 순서** **⇒** **실행 컨텍스트 스택**으로 관리

## 23.4 실행 컨텍스트 스택

```jsx
const x = 1;

function foo() {
  const y = 2;

  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}
foo();
```

![image](https://github.com/jwo0o0/Modern-Javascript-Deep-Dive/assets/70098708/94ceb655-599f-4e85-8862-d666d194a54a)


<aside>
💡 실행 컨텍스트: 스택 자료구조로 관리
- 스택의 최상위에 존재하는 실행 컨텍스트: 언제나 현재 실행 중인 코드의 실행 컨텍스트

</aside>

1. **전역 코드의 평가와 실행**

   JS 엔진: 전역 실행 컨텍스트 생성 → 실행 컨텍스트 스택에 푸시

   - 전역 변수 x와 전역 함수 foo 등록 → 값 할당

2. **foo 함수 코드의 평가와 실행**

   코드의 제어권이 foo 함수 내부로 이동 → foo 함수 실행 컨텍스트를 생성하고 스택에 푸시

3. **bar 함수 코드의 평가와 실행**

   코드의 제어권이 bar 함수 내부로 이동 → bar 함수 실행 컨텍스트를 생성하고 스택에 푸시

4. foo 함수 코드로 복귀
5. 전역 코드로 복귀

## 23.5 렉시컬 환경

> 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조

![image](https://github.com/jwo0o0/Modern-Javascript-Deep-Dive/assets/70098708/62a32df0-8419-4d8d-9ab4-97cef5f3d9db)

- **키와 값을 갖는 객체** 형태의 스코프를 생성
- **실행 컨텍스트**: `LexicalEnvironment` 컴포넌트와 `VariableEnvironment` 컴포넌트로 구성

![image](https://github.com/jwo0o0/Modern-Javascript-Deep-Dive/assets/70098708/a4d4c541-cfc9-4825-bc8f-4dca6c6ecd08)

1. **환경 레코드**(Environment Record)

   스코프에 포함된 **식별자를 등록**하고, **바인딩된 값을 관리**하는 저장소

2. **외부 렉시컬 환경에 대한 참조**

   **상위 스코프**를 가리킴. 외부 렉시컬 환경에 대한 참조로 **단방향 링크드 리스크 스코프 체인 구현**
