## 3.1 리액트의 모든 훅 파헤치기

### useState

> **함수 컴포넌트 내부에서 상태를 정의**하고, **이 상태를 관리**할 수 있게 해주는 훅

```jsx
import { useState } from "react";

const [state, setState] = useState(initialState);
```

- 초깃값을 지정하지 않으면 undefined

💡 **클로저**를 이용해 `useState` 내부의 모습을 구현한 코드

```jsx
const MyReact = (function () {
	const global = {}
	let index = 0

	function useState(initialState) {
		// 애플리케이션 전체의 states 배열을 초기화
		if (!global.states) {
			global.states = []
		}

		// states 정보를 조회해 현재 상태값을 확인하고 초깃값 설정
		const currentState = global.states[index] || initialState
		// states의 값을 위해 조회한 현재 값으로 업데이트
		global.states[index] = currentState

		// 즉시 실행 함수로 setter
		const setState = (function () {
			// 현재 index를 클로저로 가둬놔서 이후에도 동일한 index에 접근 가능
			let currentIndex = index
			return function (value) {
				global.states[currentIndex] = value
				// 컴포넌트를 렌더링
				// ...
			}
		})()

		// useState를 쓸 때마다 index를 하나씩 추가
		index = index + 1

		return [currentState, setState]
	}
}
```

- 클로저를 사용해 외부에 해당 값을 노출시키지 않고 오직 리액트에서만 사용

📌 **게으른 초기화**(lazy initialization)

```jsx
// 일반적인 사용
const [count, setCount] = useState(
  Number.parseInt(window.localStorage.getItem(cacheKey))
);
// 리렌더링시에도 동일하게 해당 값에 접근해서 낭비가 발생

// 게으른 초기화
const [count, setCount] = useState(() =>
  Number.parseInt(window.localStorage.getItem(cacheKey))
);
// 초깃값이 없다면 -> 함수 실행
// 초깃값이 있다면 -> 함수 실행을 하지 않고 기존 값을 사용
```

- `useState`에 변수 대신 함수를 넘김
- **초깃값이 복잡하거나 무거운 연산을 포함**하고 있을 때 사용
  - `localStorage`, `sessionStorage` 접근, map, filter, find 같은 배열에 대한 접근 등
- 이후에 리렌더링이 발생된다면 이 함수의 실행은 무시
