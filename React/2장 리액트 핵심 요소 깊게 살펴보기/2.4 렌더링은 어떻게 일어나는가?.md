## 2.4 렌더링은 어떻게 일어나는가?

### 리액트의 렌더링이란?

> **리액트의 렌더링**: **브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정**

리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신이 가지고 있는 props와 state 값을 기반으로 어떻게 UI를 구성하고, 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정

### 리액트의 렌더링이 일어나는 이유

1. **최초 렌더링**: 브라우저에 제공하기 위해 최초 렌더링을 수행
2. **리렌더링**: 처음 애플리케이션 진입 이후 발생하는 모든 렌더링
   - 클래스 컴포넌트의 `setState`가 실행되는 경우
   - 클래스 컴포넌트의 `forceUpdate`가 실행되는 경우
   - 함수 컴포넌트의 `useState()` 두번째 배열 요소인 setter가 실행되는 경우
   - 함수 컴포넌트의 `useReducer()`의 두번째 요소인 dispatch가 실행되는 경우
   - 컴포넌트의 **key props**가 변경되는 경우 (명시적으로 선언돼있지 않더라도 모든 컴포넌트에서 사용할 수 있는 특수한 props)
   - props가 변경되는 경우
   - 부모 컴포넌트가 렌더링될 경우 → **자식 컴포넌트도 무조건 리렌더링**이 일어남

### 리액트의 렌더링 프로세스

- 렌더링 프로세스가 시작되면
  → 리액트: 컴포넌트의 루트에서부터 아래쪽으로 내려가면서 **업데이트가 필요하다고 지정돼있는 모든 컴포넌트를 찾음**
  → 클래스 컴포넌트의 경우 `render()` 함수를 실행하고, 함수 컴포넌트의 경우 컴포넌트 자체를 호출하고 결과물을 저장
- JSX 문법으로 구성된 렌더링 결과물 ⇒ 자바스크립트로 컴파일되면서 `React.createElement()`를 호출하는 구문으로 변환
- 각 컴포넌트의 렌더링 결과물을 수집하고 → 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경사항을 수집

### 렌더와 커밋

<aside>
💡

**리액트의 렌더링 프로세스**: **렌더** 단계와 **커밋** 단계로 분리되어 실행

</aside>

> **렌더 단계**(Render Phase):
> 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업

- 컴포넌트를 실행해(render() 또는 return) 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크
- 크게 type, props, key 세 가지를 비교

> **커밋 단계**(Commit Phase):
> 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정

- 리액트가 커밋 단계에서 DOM을 업데이트하면, 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부 참조를 업데이트
  → 클래스 컴포넌트에서는 `componentDidMount`, `componentDidUpdate` 메서드를 호출, 함수 컴포넌트에서는 `useLayoutEffect` 훅을 호출

<aside>
💡

**리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아님**

- 변경 사항이 감지되지 않으면 커밋 단계가 생략될 수 있음

</aside>

- 리액트의 **렌더링 과정은 항상 동기식으로 작동** → 렌더링이 길어질 수록 애플리케이션의 성능 저하
- 리액트 18에서는 의도된 우선순위로 컴포넌트를 렌더링해 최적화하는 동시성 렌더링 도입

### 일반적인 렌더링 시나리오 살펴보기

```tsx
import { useState } from 'react';

export default function A() {
	return (
		<div className="App">
			<h1>Hello React</h1>
			<B />
		</div>
	)
}

function B() {
	const [counter, setCounter] = useState(0)

	function handleButtonClick() {
		setCounter((previous) => previous + 1)
	}

	return (
		<>
			<label>
				<C number={counter} />
			</label>
			<button onClick={handleButtonClick}>+</button>
		</>
	)
}

function C({number }) {
	return (
		<div>
			{number> <D />
		</div>
	)
}

function D() {
	return <>리액트 재밌다</>
}
```

💡 사용자가 B 컴포넌트의 버튼을 눌러 `counter` 변수를 업데이트

1. B 컴포넌트의 `setState` 호출
2. B 컴포넌트의 리렌더링 작업이 렌더링 큐에 들어감
3. 리액트가 트리 최상단에서부터 렌더링 경로 검사
4. A 컴포넌트는 리렌더링이 필요한 컴포넌트로 표시 X → 별다른 작업을 하지 않음
5. B 컴포넌트는 리렌더링이 필요한 컴포넌트로 표시 O → 리렌더링
6. 5번에서 B가 C를 반환
7. C는 props인 `number`가 업데이트 → 업데이트가 필요한 컴포넌트로 체크돼 있어 업데이트
8. 7번에서 C가 D를 반환
9. D는 업데이트가 필요한 컴포넌트로 체크되지 않음, 그러나 C가 렌더링됐으므로 렌더링
   - D 컴포넌트를 `memo`로 래핑하면 B가 리렌더링되어도 커밋 단계가 생략되어 렌더링되지 않음
